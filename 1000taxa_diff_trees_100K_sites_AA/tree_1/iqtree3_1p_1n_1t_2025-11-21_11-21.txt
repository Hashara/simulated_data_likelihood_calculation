Command:        /scratch/dx61/sa0557/iqtree2/poc_builds/ci_cd/build/iqtree_build/iqtree3 -s alignment_1000000.phy -te tree_1.full.treefile --prefix output_energy_measure_run1_tree_1_1000000_aa_iqtree -m Poisson -blfix --kernel-nonrev
Resources:      1 node (48 physical, 96 logical cores per node)
Memory:         189 GiB per node
Tasks:          1 process
Machine:        gadi-cpu-clx-1565.gadi.nci.org.au
Architecture:   x86_64
CPU Family:     cascadelake-x
Start time:     Fri Nov 21 11:21:13 2025
Total time:     1 second
Full path:      /scratch/dx61/sa0557/iqtree2/poc_builds/ci_cd/build/iqtree_build

Summary: iqtree3 is Compute-bound in this configuration
Compute:                                    100.0%     (0.1s) |=========|
MPI:                                          0.0%     (0.0s) |
I/O:                                          0.0%     (0.0s) |
This application run was Compute-bound. A breakdown of this time and advice for investigating further is in the CPU section below.
As very little time is spent in MPI calls, this code may also benefit from running at larger scales.

CPU:
A breakdown of the 100.0% (0.1s) CPU time:
Scalar numeric ops:                           0.0%     (0.0s) |
Vector numeric ops:                           0.0%     (0.0s) |
Memory accesses:                              0.0%     (0.0s) |
The CPU performance appears well-optimized for numerical computation. The biggest gains may now come from running at larger scales.

MPI:
A breakdown of the 0.0% (0.0s) MPI time:
Time in collective calls:                     0.0%     (0.0s) |
Time in point-to-point calls:                 0.0%     (0.0s) |
Effective process collective rate:            0.00 bytes/s
Effective process point-to-point rate:        0.00 bytes/s
No time is spent in MPI operations. There's nothing to optimize here!

I/O:
A breakdown of the 0.0% (0.0s) I/O time:
Time in reads:                                0.0%     (0.0s) |
Time in writes:                               0.0%     (0.0s) |
Effective process read rate:                  0.00 bytes/s
Effective process write rate:                 0.00 bytes/s
No time is spent in I/O operations. There's nothing to optimize here!

Threads:
A breakdown of how multiple threads were used:
Computation:                                  0.0%     (0.0s) |
Synchronization:                              0.0%     (0.0s) |
Physical core utilization:                    2.1%            ||
System load:                                 69.0%            |======|
No measurable time is spent in multithreaded code.
Physical core utilization is low. Try increasing the number of processes to improve performance.

Memory:
Per-process memory usage may also affect scaling:
Mean process memory usage:                    32.9 MiB
Peak process memory usage:                    35.0 MiB
Peak node memory usage:                      21.0%            |=|
The peak node memory usage is very low. Larger problem sets can be run before scaling to multiple nodes.

Energy:
A breakdown of how the 0.0103 Wh was used:
CPU:                                        100.0%            |=========|
System:                                   not supported
Mean node power:                          not supported
Peak node power:                              0.00 W
The whole system energy has been calculated using the CPU energy usage.
System power metrics: Cray power not supported

